function out = computeHreflexParameters(strideEvents,HreflexData, ...
    EMGData,slowLeg)
%This function computes summary parameters per stride for the H-reflex data
%   This function outputs a 'parameterSeries' object, which can be
% concatenated with other 'parameterSeries' objects, for example, with
% those from 'computeTemporalParameters'. While this function is used for
% H-reflex parameters exclusively, it should work for any 'labTS' object.
% This function computes summary parameters per stride across three
% different muscles: SOL, MG, and LG.
%
% See also computeSpatialParameters, computeTemporalParameters,
% computeForceParameters, parameterSeries

% TODO: accept GRF data as input argument (if necessary) to leave as NaN
% strides for which stim occurs during double rather than single stance
% TODO: store parameters as a structure if possible to convert to
% 'parameterSeries' object to code readability (i.e., far fewer lines)

%% Gait Stride Event Times
timeSHS = strideEvents.tSHS;    % array of slow heel strike event times
timeFHS = strideEvents.tFHS;    % array of fast heel strike event times
timeSTO = strideEvents.tSTO;    % Slow Toe Off event times
timeFTO = strideEvents.tFTO;    % Fast Toe Off event times
timeSHS2 = strideEvents.tSHS2;  % 2nd Slow Heel Strike event times
timeFHS2 = strideEvents.tFHS2;  % 2nd Fast Heel Strike event times

%% Labels & Descriptions
muscles = {'SOL','MG','LG'};
legs = {'Slow','Fast'};
% H-reflex stimulation timing and amplitude parameters
% TODO: add convenience parameter for percentage of stance phase
% TODO: consider implementing Wilson Amplitude background EMG parameter
% TODO: store timing of the H- and M-waves?
% "The H-reflex amplitude is simply the peak-to-peak measurement of reflex,
% and the BEMG is the average rectified EMG amplitude present in the muscle
% for some period before the stimulation. The window for BEMG measurement
% is typically between 50 and 100 milliseconds."
%   "The Hoffmann reflex: Methodologic considerations and applications for
%   use in sports medicine and athletic training research" Palmieri et al.
aux = { ...
    'stimTimeFromStanceSlow',       'time from SHS to slow leg stim (in s)'; ...
    'stimTimeFromStanceFast',       'time from FHS to fast leg stim (in s)'; ...
    'stimTimeFromSingleStanceSlow', 'time from FTO to slow leg stim (in s)'; ...
    'stimTimeFromSingleStanceFast', 'time from STO to fast leg stim (in s)'; ...
    'isSingleStanceSlow',           'is stim during slow leg single stance phase?'; ...
    'isSingleStanceFast',           'is stim during fast leg single stance phase?'; ...
    'HwaveAmpSlowSOL',              'peak-to-peak voltage of the slow leg SOL H-wave (in mV)'; ...
    'HwaveAmpFastSOL',              'peak-to-peak voltage of the fast leg SOL H-wave (in mV)'; ...
    'MwaveAmpSlowSOL',              'peak-to-peak voltage of the slow leg SOL M-wave (in mV)'; ...
    'MwaveAmpFastSOL',              'peak-to-peak voltage of the fast leg SOL M-wave (in mV)'; ...
    'HreflexNoiseAmpSlowSOL',       'peak-to-peak voltage of the slow leg SOL noise (in mV)'; ...
    'HreflexNoiseAmpFastSOL',       'peak-to-peak voltage of the fast leg SOL noise (in mV)'; ...
    'H2MAmpRatioSlowSOL',           'ratio of the slow leg SOL H-wave to M-wave amplitudes'; ...
    'H2MAmpRatioFastSOL',           'ratio of the slow leg SOL H-wave to M-wave amplitudes'; ...
    'HwaveRMSSlowSOL',              'root mean square over the slow leg SOL H-wave window (in mV)'; ...
    'HwaveRMSFastSOL',              'root mean square over the fast leg SOL H-wave window (in mV)'; ...
    'MwaveRMSSlowSOL',              'root mean square over the slow leg SOL M-wave window (in mV)'; ...
    'MwaveRMSFastSOL',              'root mean square over the fast leg SOL M-wave window (in mV)'; ...
    'HreflexNoiseRMSSlowSOL',       'root mean square over the slow leg SOL noise window (in mV)'; ...
    'HreflexNoiseRMSFastSOL',       'root mean square over the fast leg SOL noise window (in mV)'; ...
    'H2MRMSRatioSlowSOL',           'ratio of the slow leg SOL H-wave to M-wave RMS'; ...
    'H2MRMSRatioFastSOL',           'ratio of the slow leg SOL H-wave to M-wave RMS'; ...
    'HwaveAmpSlowMG',               'peak-to-peak voltage of the slow leg MG H-wave (in mV)'; ...
    'HwaveAmpFastMG',               'peak-to-peak voltage of the fast leg MG H-wave (in mV)'; ...
    'MwaveAmpSlowMG',               'peak-to-peak voltage of the slow leg MG M-wave (in mV)'; ...
    'MwaveAmpFastMG',               'peak-to-peak voltage of the fast leg MG M-wave (in mV)'; ...
    'HreflexNoiseAmpSlowMG',        'peak-to-peak voltage of the slow leg MG noise (in mV)'; ...
    'HreflexNoiseAmpFastMG',        'peak-to-peak voltage of the fast leg MG noise (in mV)'; ...
    'H2MAmpRatioSlowMG',            'ratio of the slow leg MG H-wave to M-wave amplitudes'; ...
    'H2MAmpRatioFastMG',            'ratio of the slow leg MG H-wave to M-wave amplitudes'; ...
    'HwaveRMSSlowMG',               'root mean square over the slow leg MG H-wave window (in mV)'; ...
    'HwaveRMSFastMG',               'root mean square over the fast leg MG H-wave window (in mV)'; ...
    'MwaveRMSSlowMG',               'root mean square over the slow leg MG M-wave window (in mV)'; ...
    'MwaveRMSFastMG',               'root mean square over the fast leg MG M-wave window (in mV)'; ...
    'HreflexNoiseRMSSlowMG',        'root mean square over the slow leg MG noise window (in mV)'; ...
    'HreflexNoiseRMSFastMG',        'root mean square over the fast leg MG noise window (in mV)'; ...
    'H2MRMSRatioSlowMG',            'ratio of the slow leg MG H-wave to M-wave RMS'; ...
    'H2MRMSRatioFastMG',            'ratio of the slow leg MG H-wave to M-wave RMS'; ...
    'HwaveAmpSlowLG',               'peak-to-peak voltage of the slow leg LG H-wave (in mV)'; ...
    'HwaveAmpFastLG',               'peak-to-peak voltage of the fast leg LG H-wave (in mV)'; ...
    'MwaveAmpSlowLG',               'peak-to-peak voltage of the slow leg LG M-wave (in mV)'; ...
    'MwaveAmpFastLG',               'peak-to-peak voltage of the fast leg LG M-wave (in mV)'; ...
    'HreflexNoiseAmpSlowLG',        'peak-to-peak voltage of the slow leg LG noise (in mV)'; ...
    'HreflexNoiseAmpFastLG',        'peak-to-peak voltage of the fast leg LG noise (in mV)'; ...
    'H2MAmpRatioSlowLG',            'ratio of the slow leg LG H-wave to M-wave amplitudes'; ...
    'H2MAmpRatioFastLG',            'ratio of the slow leg LG H-wave to M-wave amplitudes'; ...
    'HwaveRMSSlowLG',               'root mean square over the slow leg LG H-wave window (in mV)'; ...
    'HwaveRMSFastLG',               'root mean square over the fast leg LG H-wave window (in mV)'; ...
    'MwaveRMSSlowLG',               'root mean square over the slow leg LG M-wave window (in mV)'; ...
    'MwaveRMSFastLG',               'root mean square over the fast leg LG M-wave window (in mV)'; ...
    'HreflexNoiseRMSSlowLG',        'root mean square over the slow leg LG noise window (in mV)'; ...
    'HreflexNoiseRMSFastLG',        'root mean square over the fast leg LG noise window (in mV)'; ...
    'H2MRMSRatioSlowLG',            'ratio of the slow leg LG H-wave to M-wave RMS'; ...
    'H2MRMSRatioFastLG',            'ratio of the slow leg LG H-wave to M-wave RMS'};

% TODO: Re-add background EMG parameters
% 'HreflexBEMGMAVSlowSOL',   'mean absolute value of the slow leg background EMG (in mV)'; ...
% 'HreflexBEMGMAVFastSOL',   'mean absolute value of the fast leg background EMG (in mV)'; ...
% 'HreflexBEMGRMSSlowSOL',   'root mean square of the slow leg background EMG (in mV)'; ...
% 'HreflexBEMGRMSFastSOL',   'root mean square of the fast leg background EMG (in mV)'; ...
% 'HreflexBEMGMAVSlowMG',   'mean absolute value of the slow leg background EMG (in mV)'; ...
% 'HreflexBEMGMAVFastMG',   'mean absolute value of the fast leg background EMG (in mV)'; ...
% 'HreflexBEMGRMSSlowMG',   'root mean square of the slow leg background EMG (in mV)'; ...
% 'HreflexBEMGRMSFastMG',   'root mean square of the fast leg background EMG (in mV)'; ...
% 'HreflexBEMGMAVSlowLG',   'mean absolute value of the slow leg background EMG (in mV)'; ...
% 'HreflexBEMGMAVFastLG',   'mean absolute value of the fast leg background EMG (in mV)'; ...
% 'HreflexBEMGRMSSlowLG',   'root mean square of the slow leg background EMG (in mV)'; ...
% 'HreflexBEMGRMSFastLG',   'root mean square of the fast leg background EMG (in mV)'; ...

paramLabels = aux(:,1);
description = aux(:,2);

%% Initialize All Parameter Arrays
% initialize parameter arrays: stimulation timing and H-reflex amplitudes
% (i.e., peak-to-peak voltages and RMS)
stimTimeFromStanceSlow = nan(size(timeSHS));
stimTimeFromStanceFast = nan(size(timeFHS));
stimTimeFromSingleStanceSlow = nan(size(timeSHS));
stimTimeFromSingleStanceFast = nan(size(timeFHS));
isSingleStanceSlow = false(size(timeSHS));  % TODO: initialize true or NaN?
isSingleStanceFast = false(size(timeFHS));

for m = 1:length(muscles)               % for each muscle of interest, ...
    muscle = muscles{m};                % name of current muscle
    for l = 1:2                         % for slow (1) & fast (2) leg, ...
        leg = legs{l};                  % name of current leg
        % initialize parameter data arrays
        eval(['HwaveAmp' leg muscle ' = nan(size(time' leg(1) 'HS));']);
        eval(['MwaveAmp' leg muscle ' = nan(size(time' leg(1) 'HS));']);
        eval(['HreflexNoiseAmp' leg muscle ' = nan(size(time' leg(1) 'HS));']);
        eval(['H2MAmpRatio' leg muscle ' = nan(size(time' leg(1) 'HS));']);
        eval(['HwaveRMS' leg muscle ' = nan(size(time' leg(1) 'HS));']);
        eval(['MwaveRMS' leg muscle ' = nan(size(time' leg(1) 'HS));']);
        eval(['HreflexNoiseRMS' leg muscle ' = nan(size(time' leg(1) 'HS));']);
        eval(['H2MRMSRatio' leg muscle ' = nan(size(time' leg(1) 'HS));']);
    end
end

%% Identify Stimulus Artifact Indices
% extract time for the trial, and use proximal TA to localize stim artifact
[EMG_RTAP,times] = EMGData.getDataAsVector('RTAP');
EMG_LTAP = EMGData.getDataAsVector('LTAP');
stimTrigR = HreflexData.getDataAsVector( ...
    'Stimulator_Trigger_Sync_Right_Stimulator');
stimTrigL = HreflexData.getDataAsVector( ...
    'Stimulator_Trigger_Sync_Left__Stimulator');
indsStimArtifact = Hreflex.extractStimArtifactIndsFromTrigger( ...
    times,{EMG_RTAP,EMG_LTAP},{stimTrigR,stimTrigL});

if all(cellfun(@isempty,indsStimArtifact))          % if no stim, ...
    data = nan(length(timeSHS),length(paramLabels));
    for ii = 1:length(paramLabels)
        eval(['data(:,i) = ' paramLabels{ii} ';']);
    end
    out = parameterSeries(data,paramLabels,[],description);
    return;                                         % return from function
end

%% Determine Which Leg is Slow and Which Leg is Fast
switch lower(slowLeg)   % which leg is slow, R or L
    case 'r'            % if right leg is slow, ...
        indSlow = 1;
        indFast = 2;
    case 'l'            % if left leg is slow, ...
        indSlow = 2;
        indFast = 1;
    otherwise           % otherwise, throw an error
        error('Invalid slow leg input argument, must be ''R'' or ''L''');
end

%% Compute H-Reflex Temporal Parameters
% NaN values give false in logical comparison
indsComp = all(~isnan([timeSHS timeFHS]),2);    % comparison inds (no NaNs)
% TODO: could also check the SHS2 and FHS2 times to be ultra safe
isSlowFirst = all(timeSHS(indsComp) < timeFHS(indsComp));

% find indices of nearest stride heel strike to the time of stim
% NOTE: this **should** be identical but may not be due to missed
% stimulation pulses, especially at start or end of trial (however,
% there should not be substantial differences in stride indices)
% TODO: add data check to warn if stride indices are considerably
% different across legs (i.e., not including strides where stim was missed)
timeStimSlow = times(indsStimArtifact{indSlow});
timeStimFast = times(indsStimArtifact{indFast});

% discard stimuli that occur too early (e.g., when H-reflex stim happens
% during a transition into a new condition or before a first valid HS is
% detected) or too late (e.g., more than 1 second after final HS)
% TODO: 1 second may not be the correct threshold here
shouldDiscardStimSlow = (timeStimSlow <= timeSHS(1)) | ...
    (timeStimSlow >= (timeSHS(end)+1));
shouldDiscardStimFast = (timeStimFast <= timeFHS(1)) | ...
    (timeStimFast >= (timeFHS(end)+1));
timeStimSlow = timeStimSlow(~shouldDiscardStimSlow);
timeStimFast = timeStimFast(~shouldDiscardStimFast);

if any(shouldDiscardStimSlow)               % if discarding any stim, ...
    warning('Dropping %d stimuli for the slow leg', ...
        sum(shouldDiscardStimSlow));
end
if any(shouldDiscardStimFast)
    warning('Dropping %d stimuli for the fast leg', ...
        sum(shouldDiscardStimFast));
end

indsStimStrideSlow = arrayfun(@(x) ...
    find((x - timeSHS) > 0,1,'last'),timeStimSlow);
indsStimStrideFast = arrayfun(@(x) ...
    find((x - timeFHS) > 0,1,'last'),timeStimFast);

% populate the times for the strides that have stimulation
stimTimeFromStanceSlow(indsStimStrideSlow) = timeStimSlow - ...
    timeSHS(indsStimStrideSlow);
stimTimeFromStanceFast(indsStimStrideFast) = timeStimFast - ...
    timeFHS(indsStimStrideFast);
stimTimeFromSingleStanceSlow(indsStimStrideSlow) = timeStimSlow - ...
    timeFTO(indsStimStrideSlow);
stimTimeFromSingleStanceFast(indsStimStrideFast) = timeStimFast - ...
    timeSTO(indsStimStrideFast);
if isSlowFirst  % if slow leg heel strikes first, ...
    % TODO: conditions return false if time is NaN - implement handling
    isSingleStanceSlow(indsStimStrideSlow) = ...
        (timeStimSlow > timeSHS(indsStimStrideSlow)) & ...
        (timeStimSlow < timeFHS(indsStimStrideSlow));
    isSingleStanceFast(indsStimStrideFast) = ...
        (timeStimFast > timeFHS(indsStimStrideFast)) & ...
        (timeStimFast < timeSHS2(indsStimStrideFast));
else            % otherwise, fast leg heel strikes first, ...
    isSingleStanceFast(indsStimStrideFast) = ...
        (timeStimFast > timeFHS(indsStimStrideFast)) & ...
        (timeStimFast < timeSHS(indsStimStrideFast));
    isSingleStanceSlow(indsStimStrideSlow) = ...
        (timeStimSlow > timeSHS(indsStimStrideSlow)) & ...
        (timeStimSlow < timeFHS2(indsStimStrideSlow));
end

%% Extract EMG Signal for Each H-Reflex Muscle of Interest
EMG_RSOL = EMGData.getDataAsVector('RSOL');
EMG_LSOL = EMGData.getDataAsVector('LSOL');
EMG_RMG = EMGData.getDataAsVector('RMG');
EMG_LMG = EMGData.getDataAsVector('LMG');
EMG_RLG = EMGData.getDataAsVector('RLG');
EMG_LLG = EMGData.getDataAsVector('LLG');

% organize EMG Data for Each Muscle
EMGDataByMuscle = {EMG_RSOL,EMG_LSOL; EMG_RMG,EMG_LMG; EMG_RLG,EMG_LLG};

%% Compute H-Reflex Parameters for Each Muscle of Interest
% TODO: further consolidate and optimize the below code
for m = 1:length(muscles)               % for each muscle of interest, ...
    muscle = muscles{m};                % name of current muscle
    snippets = Hreflex.extractSnippets( ...
        indsStimArtifact,EMGDataByMuscle(m,:)');
    [amps,rms] = Hreflex.computeAmplitudes(snippets(:,1));
    % convert wave amplitudes from Volts to Millivolts
    amps = cellfun(@(x) 1000.*x,amps,'UniformOutput',false);
    rms = cellfun(@(x) 1000.*x,rms,'UniformOutput',false);

    % remove stim values for steps to discard for each leg
    amps(indSlow,:) = cellfun(@(x) x(~shouldDiscardStimSlow), ...
        amps(indSlow,:),'UniformOutput',false);
    amps(indFast,:) = cellfun(@(x) x(~shouldDiscardStimFast), ...
        amps(indFast,:),'UniformOutput',false);
    rms(indSlow,:) = cellfun(@(x) x(~shouldDiscardStimSlow), ...
        rms(indSlow,:),'UniformOutput',false);
    rms(indFast,:) = cellfun(@(x) x(~shouldDiscardStimFast), ...
        rms(indFast,:),'UniformOutput',false);

    % assign data to correct parameter
    eval(['HwaveAmpSlow' muscle '(indsStimStrideSlow) = amps{indSlow,2};']);
    eval(['HwaveAmpFast' muscle '(indsStimStrideFast) = amps{indFast,2};']);
    eval(['MwaveAmpSlow' muscle '(indsStimStrideSlow) = amps{indSlow,1};']);
    eval(['MwaveAmpFast' muscle '(indsStimStrideFast) = amps{indFast,1};']);
    eval(['HreflexNoiseAmpSlow' muscle '(indsStimStrideSlow) = amps{indSlow,3};']);
    eval(['HreflexNoiseAmpFast' muscle '(indsStimStrideFast) = amps{indFast,3};']);
    eval(['H2MAmpRatioSlow' muscle '(indsStimStrideSlow) = amps{indSlow,2} ./ amps{indSlow,1};']);
    eval(['H2MAmpRatioFast' muscle '(indsStimStrideFast) = amps{indFast,2} ./ amps{indFast,1};']);
    eval(['HwaveRMSSlow' muscle '(indsStimStrideSlow) = rms{indSlow,2};']);
    eval(['HwaveRMSFast' muscle '(indsStimStrideFast) = rms{indFast,2};']);
    eval(['MwaveRMSSlow' muscle '(indsStimStrideSlow) = rms{indSlow,1};']);
    eval(['MwaveRMSFast' muscle '(indsStimStrideFast) = rms{indFast,1};']);
    eval(['HreflexNoiseRMSSlow' muscle '(indsStimStrideSlow) = rms{indSlow,3};']);
    eval(['HreflexNoiseRMSFast' muscle '(indsStimStrideFast) = rms{indFast,3};']);
    eval(['H2MRMSRatioSlow' muscle '(indsStimStrideSlow) = rms{indSlow,2} ./ rms{indSlow,1};']);
    eval(['H2MRMSRatioFast' muscle '(indsStimStrideFast) = rms{indFast,2} ./ rms{indFast,1};']);
end

%% Assign Parameters to the Data Matrix
data = nan(length(timeSHS),length(paramLabels));
for ii=1:length(paramLabels)
    eval(['data(:,i) = ' paramLabels{ii} ';']);
end

%% Output the Computed Parameters
out = parameterSeries(data,paramLabels,[],description);

end

